//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class DataLayerClientBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5280";

    }

    /**
     * @return Success
     */
    languageAll(  cancelToken?: CancelToken | undefined): Promise<Language[]> {
        let url_ = this.baseUrl + "/api/Language";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageAll(_response);
        });
    }

    protected processLanguageAll(response: AxiosResponse): Promise<Language[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Language.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Language[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Language[]>(null as any);
    }

    /**
     * @return Success
     */
    language(id: string , cancelToken?: CancelToken | undefined): Promise<Language> {
        let url_ = this.baseUrl + "/api/Language/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguage(_response);
        });
    }

    protected processLanguage(response: AxiosResponse): Promise<Language> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Language.fromJS(resultData200);
            return Promise.resolve<Language>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Language>(null as any);
    }

    /**
     * @return Success
     */
    languageLevelAll(  cancelToken?: CancelToken | undefined): Promise<LanguageLevel[]> {
        let url_ = this.baseUrl + "/api/LanguageLevel";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLevelAll(_response);
        });
    }

    protected processLanguageLevelAll(response: AxiosResponse): Promise<LanguageLevel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageLevel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LanguageLevel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageLevel[]>(null as any);
    }

    /**
     * @return Success
     */
    languageLevel(id: string , cancelToken?: CancelToken | undefined): Promise<LanguageLevel> {
        let url_ = this.baseUrl + "/api/LanguageLevel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLevel(_response);
        });
    }

    protected processLanguageLevel(response: AxiosResponse): Promise<LanguageLevel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageLevel.fromJS(resultData200);
            return Promise.resolve<LanguageLevel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageLevel>(null as any);
    }

    /**
     * @return Success
     */
    languageLinkAll(  cancelToken?: CancelToken | undefined): Promise<LanguageLink[]> {
        let url_ = this.baseUrl + "/api/LanguageLink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLinkAll(_response);
        });
    }

    protected processLanguageLinkAll(response: AxiosResponse): Promise<LanguageLink[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageLink.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LanguageLink[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageLink[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    languageLinkPOST(body: LanguageLink | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/LanguageLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLinkPOST(_response);
        });
    }

    protected processLanguageLinkPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    languageLinkGET(id: string , cancelToken?: CancelToken | undefined): Promise<LanguageLink> {
        let url_ = this.baseUrl + "/api/LanguageLink/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLinkGET(_response);
        });
    }

    protected processLanguageLinkGET(response: AxiosResponse): Promise<LanguageLink> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageLink.fromJS(resultData200);
            return Promise.resolve<LanguageLink>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageLink>(null as any);
    }

    /**
     * @return Success
     */
    matchAll(  cancelToken?: CancelToken | undefined): Promise<Match[]> {
        let url_ = this.baseUrl + "/api/Match";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMatchAll(_response);
        });
    }

    protected processMatchAll(response: AxiosResponse): Promise<Match[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Match.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Match[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Match[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    matchPOST(body: Match | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Match";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMatchPOST(_response);
        });
    }

    protected processMatchPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    matchGET(id: string , cancelToken?: CancelToken | undefined): Promise<Match> {
        let url_ = this.baseUrl + "/api/Match/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMatchGET(_response);
        });
    }

    protected processMatchGET(response: AxiosResponse): Promise<Match> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Match.fromJS(resultData200);
            return Promise.resolve<Match>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Match>(null as any);
    }

    /**
     * @return Success
     */
    personAll(  cancelToken?: CancelToken | undefined): Promise<Person[]> {
        let url_ = this.baseUrl + "/api/Person";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonAll(_response);
        });
    }

    protected processPersonAll(response: AxiosResponse): Promise<Person[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Person.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Person[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Person[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    personPOST(body: Person | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Person";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonPOST(_response);
        });
    }

    protected processPersonPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    personGET(id: string , cancelToken?: CancelToken | undefined): Promise<Person> {
        let url_ = this.baseUrl + "/api/Person/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonGET(_response);
        });
    }

    protected processPersonGET(response: AxiosResponse): Promise<Person> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Person.fromJS(resultData200);
            return Promise.resolve<Person>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Person>(null as any);
    }

    /**
     * @return Success
     */
    researchAll(  cancelToken?: CancelToken | undefined): Promise<Research[]> {
        let url_ = this.baseUrl + "/api/Research";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResearchAll(_response);
        });
    }

    protected processResearchAll(response: AxiosResponse): Promise<Research[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Research.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Research[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Research[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    researchPOST(body: Research | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Research";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResearchPOST(_response);
        });
    }

    protected processResearchPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    researchGET(id: string , cancelToken?: CancelToken | undefined): Promise<Research> {
        let url_ = this.baseUrl + "/api/Research/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResearchGET(_response);
        });
    }

    protected processResearchGET(response: AxiosResponse): Promise<Research> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Research.fromJS(resultData200);
            return Promise.resolve<Research>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Research>(null as any);
    }

    /**
     * @return Success
     */
    siteAll(  cancelToken?: CancelToken | undefined): Promise<Site[]> {
        let url_ = this.baseUrl + "/api/Site";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSiteAll(_response);
        });
    }

    protected processSiteAll(response: AxiosResponse): Promise<Site[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Site.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Site[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Site[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitePOST(body: Site | undefined , cancelToken?: CancelToken | undefined): Promise<HttpResponseMessage> {
        let url_ = this.baseUrl + "/api/Site";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSitePOST(_response);
        });
    }

    protected processSitePOST(response: AxiosResponse): Promise<HttpResponseMessage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HttpResponseMessage.fromJS(resultData200);
            return Promise.resolve<HttpResponseMessage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HttpResponseMessage>(null as any);
    }

    /**
     * @return Success
     */
    siteGET(id: string , cancelToken?: CancelToken | undefined): Promise<Site> {
        let url_ = this.baseUrl + "/api/Site/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSiteGET(_response);
        });
    }

    protected processSiteGET(response: AxiosResponse): Promise<Site> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Site.fromJS(resultData200);
            return Promise.resolve<Site>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Site>(null as any);
    }

    /**
     * @return Success
     */
    skillAll(  cancelToken?: CancelToken | undefined): Promise<Skill[]> {
        let url_ = this.baseUrl + "/api/Skill";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillAll(_response);
        });
    }

    protected processSkillAll(response: AxiosResponse): Promise<Skill[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Skill.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Skill[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Skill[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    skillPOST(body: Skill | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Skill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillPOST(_response);
        });
    }

    protected processSkillPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    skillGET(id: string , cancelToken?: CancelToken | undefined): Promise<Skill> {
        let url_ = this.baseUrl + "/api/Skill/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillGET(_response);
        });
    }

    protected processSkillGET(response: AxiosResponse): Promise<Skill> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Skill.fromJS(resultData200);
            return Promise.resolve<Skill>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Skill>(null as any);
    }

    /**
     * @return Success
     */
    skillLinkAll(  cancelToken?: CancelToken | undefined): Promise<SkillLink[]> {
        let url_ = this.baseUrl + "/api/SkillLink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillLinkAll(_response);
        });
    }

    protected processSkillLinkAll(response: AxiosResponse): Promise<SkillLink[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkillLink.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SkillLink[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SkillLink[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    skillLinkPOST(body: SkillLink | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/SkillLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillLinkPOST(_response);
        });
    }

    protected processSkillLinkPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    skillLinkGET(id: string , cancelToken?: CancelToken | undefined): Promise<SkillLink> {
        let url_ = this.baseUrl + "/api/SkillLink/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillLinkGET(_response);
        });
    }

    protected processSkillLinkGET(response: AxiosResponse): Promise<SkillLink> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SkillLink.fromJS(resultData200);
            return Promise.resolve<SkillLink>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SkillLink>(null as any);
    }
}

export class HttpContent {
    readonly headers?: StringStringIEnumerableKeyValuePair[] | null;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["headers"])) {
                (<any>this).headers = [] as any;
                for (let item of _data["headers"])
                    (<any>this).headers!.push(StringStringIEnumerableKeyValuePair.fromJS(item));
            }
            else {
                (<any>this).headers = <any>null;
            }
        }
    }

    static fromJS(data: any): HttpContent {
        data = typeof data === 'object' ? data : {};
        let result = new HttpContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.headers)) {
            data["headers"] = [];
            for (let item of this.headers)
                data["headers"].push(item.toJSON());
        }
        return data;
    }
}

export class HttpMethod {
    method?: string | null;

    init(_data?: any) {
        if (_data) {
            this.method = _data["method"] !== undefined ? _data["method"] : <any>null;
        }
    }

    static fromJS(data: any): HttpMethod {
        data = typeof data === 'object' ? data : {};
        let result = new HttpMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["method"] = this.method !== undefined ? this.method : <any>null;
        return data;
    }
}

export class HttpRequestMessage {
    version?: Version;
    versionPolicy?: HttpVersionPolicy;
    content?: HttpContent;
    method?: HttpMethod;
    requestUri?: string | null;
    readonly headers?: StringStringIEnumerableKeyValuePair[] | null;
    readonly properties?: { [key: string]: any; } | null;
    readonly options?: { [key: string]: any; } | null;

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] ? Version.fromJS(_data["version"]) : <any>null;
            this.versionPolicy = _data["versionPolicy"] !== undefined ? _data["versionPolicy"] : <any>null;
            this.content = _data["content"] ? HttpContent.fromJS(_data["content"]) : <any>null;
            this.method = _data["method"] ? HttpMethod.fromJS(_data["method"]) : <any>null;
            this.requestUri = _data["requestUri"] !== undefined ? _data["requestUri"] : <any>null;
            if (Array.isArray(_data["headers"])) {
                (<any>this).headers = [] as any;
                for (let item of _data["headers"])
                    (<any>this).headers!.push(StringStringIEnumerableKeyValuePair.fromJS(item));
            }
            else {
                (<any>this).headers = <any>null;
            }
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key] !== undefined ? _data["properties"][key] : <any>null;
                }
            }
            else {
                (<any>this).properties = <any>null;
            }
            if (_data["options"]) {
                (<any>this).options = {} as any;
                for (let key in _data["options"]) {
                    if (_data["options"].hasOwnProperty(key))
                        (<any>(<any>this).options)![key] = _data["options"][key] !== undefined ? _data["options"][key] : <any>null;
                }
            }
            else {
                (<any>this).options = <any>null;
            }
        }
    }

    static fromJS(data: any): HttpRequestMessage {
        data = typeof data === 'object' ? data : {};
        let result = new HttpRequestMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version ? this.version.toJSON() : <any>null;
        data["versionPolicy"] = this.versionPolicy !== undefined ? this.versionPolicy : <any>null;
        data["content"] = this.content ? this.content.toJSON() : <any>null;
        data["method"] = this.method ? this.method.toJSON() : <any>null;
        data["requestUri"] = this.requestUri !== undefined ? this.requestUri : <any>null;
        if (Array.isArray(this.headers)) {
            data["headers"] = [];
            for (let item of this.headers)
                data["headers"].push(item.toJSON());
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = this.properties[key] !== undefined ? this.properties[key] : <any>null;
            }
        }
        if (this.options) {
            data["options"] = {};
            for (let key in this.options) {
                if (this.options.hasOwnProperty(key))
                    (<any>data["options"])[key] = this.options[key] !== undefined ? this.options[key] : <any>null;
            }
        }
        return data;
    }
}

export class HttpResponseMessage {
    version?: Version;
    content?: HttpContent;
    statusCode?: HttpStatusCode;
    reasonPhrase?: string | null;
    readonly headers?: StringStringIEnumerableKeyValuePair[] | null;
    readonly trailingHeaders?: StringStringIEnumerableKeyValuePair[] | null;
    requestMessage?: HttpRequestMessage;
    readonly isSuccessStatusCode?: boolean;

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] ? Version.fromJS(_data["version"]) : <any>null;
            this.content = _data["content"] ? HttpContent.fromJS(_data["content"]) : <any>null;
            this.statusCode = _data["statusCode"] !== undefined ? _data["statusCode"] : <any>null;
            this.reasonPhrase = _data["reasonPhrase"] !== undefined ? _data["reasonPhrase"] : <any>null;
            if (Array.isArray(_data["headers"])) {
                (<any>this).headers = [] as any;
                for (let item of _data["headers"])
                    (<any>this).headers!.push(StringStringIEnumerableKeyValuePair.fromJS(item));
            }
            else {
                (<any>this).headers = <any>null;
            }
            if (Array.isArray(_data["trailingHeaders"])) {
                (<any>this).trailingHeaders = [] as any;
                for (let item of _data["trailingHeaders"])
                    (<any>this).trailingHeaders!.push(StringStringIEnumerableKeyValuePair.fromJS(item));
            }
            else {
                (<any>this).trailingHeaders = <any>null;
            }
            this.requestMessage = _data["requestMessage"] ? HttpRequestMessage.fromJS(_data["requestMessage"]) : <any>null;
            (<any>this).isSuccessStatusCode = _data["isSuccessStatusCode"] !== undefined ? _data["isSuccessStatusCode"] : <any>null;
        }
    }

    static fromJS(data: any): HttpResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version ? this.version.toJSON() : <any>null;
        data["content"] = this.content ? this.content.toJSON() : <any>null;
        data["statusCode"] = this.statusCode !== undefined ? this.statusCode : <any>null;
        data["reasonPhrase"] = this.reasonPhrase !== undefined ? this.reasonPhrase : <any>null;
        if (Array.isArray(this.headers)) {
            data["headers"] = [];
            for (let item of this.headers)
                data["headers"].push(item.toJSON());
        }
        if (Array.isArray(this.trailingHeaders)) {
            data["trailingHeaders"] = [];
            for (let item of this.trailingHeaders)
                data["trailingHeaders"].push(item.toJSON());
        }
        data["requestMessage"] = this.requestMessage ? this.requestMessage.toJSON() : <any>null;
        data["isSuccessStatusCode"] = this.isSuccessStatusCode !== undefined ? this.isSuccessStatusCode : <any>null;
        return data;
    }
}

export enum HttpStatusCode {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export enum HttpVersionPolicy {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Language {
    languageId?: string;
    code?: number;
    description?: string | null;

    init(_data?: any) {
        if (_data) {
            this.languageId = _data["languageId"] !== undefined ? _data["languageId"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageId"] = this.languageId !== undefined ? this.languageId : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export class LanguageLevel {
    languageLevelId?: string;
    code?: number;
    description?: string | null;

    init(_data?: any) {
        if (_data) {
            this.languageLevelId = _data["languageLevelId"] !== undefined ? _data["languageLevelId"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): LanguageLevel {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageLevelId"] = this.languageLevelId !== undefined ? this.languageLevelId : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export class LanguageLink {
    languageLinkId?: string;
    languageId?: string;
    personId?: string;
    languageLevelId?: string | null;
    preferred?: boolean | null;
    language?: Language;
    person?: Person;
    languageLevel?: LanguageLevel;

    init(_data?: any) {
        if (_data) {
            this.languageLinkId = _data["languageLinkId"] !== undefined ? _data["languageLinkId"] : <any>null;
            this.languageId = _data["languageId"] !== undefined ? _data["languageId"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.languageLevelId = _data["languageLevelId"] !== undefined ? _data["languageLevelId"] : <any>null;
            this.preferred = _data["preferred"] !== undefined ? _data["preferred"] : <any>null;
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.languageLevel = _data["languageLevel"] ? LanguageLevel.fromJS(_data["languageLevel"]) : <any>null;
        }
    }

    static fromJS(data: any): LanguageLink {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageLinkId"] = this.languageLinkId !== undefined ? this.languageLinkId : <any>null;
        data["languageId"] = this.languageId !== undefined ? this.languageId : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["languageLevelId"] = this.languageLevelId !== undefined ? this.languageLevelId : <any>null;
        data["preferred"] = this.preferred !== undefined ? this.preferred : <any>null;
        data["language"] = this.language ? this.language.toJSON() : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["languageLevel"] = this.languageLevel ? this.languageLevel.toJSON() : <any>null;
        return data;
    }
}

export class Match {
    matchId?: string;
    employeeId?: string | null;
    researchId?: string | null;
    matchAcceptedByEmployee?: boolean | null;
    person?: Person;
    research?: Research;

    init(_data?: any) {
        if (_data) {
            this.matchId = _data["matchId"] !== undefined ? _data["matchId"] : <any>null;
            this.employeeId = _data["employeeId"] !== undefined ? _data["employeeId"] : <any>null;
            this.researchId = _data["researchId"] !== undefined ? _data["researchId"] : <any>null;
            this.matchAcceptedByEmployee = _data["matchAcceptedByEmployee"] !== undefined ? _data["matchAcceptedByEmployee"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.research = _data["research"] ? Research.fromJS(_data["research"]) : <any>null;
        }
    }

    static fromJS(data: any): Match {
        data = typeof data === 'object' ? data : {};
        let result = new Match();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["matchId"] = this.matchId !== undefined ? this.matchId : <any>null;
        data["employeeId"] = this.employeeId !== undefined ? this.employeeId : <any>null;
        data["researchId"] = this.researchId !== undefined ? this.researchId : <any>null;
        data["matchAcceptedByEmployee"] = this.matchAcceptedByEmployee !== undefined ? this.matchAcceptedByEmployee : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["research"] = this.research ? this.research.toJSON() : <any>null;
        return data;
    }
}

export class Person {
    personId?: string;
    code?: number;
    name?: string | null;
    surnamme?: string | null;
    siteId?: string | null;
    yearsOfExperience?: number | null;
    position?: string | null;
    remote?: boolean;
    isRecruiter?: boolean;
    site?: Site;

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.surnamme = _data["surnamme"] !== undefined ? _data["surnamme"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.yearsOfExperience = _data["yearsOfExperience"] !== undefined ? _data["yearsOfExperience"] : <any>null;
            this.position = _data["position"] !== undefined ? _data["position"] : <any>null;
            this.remote = _data["remote"] !== undefined ? _data["remote"] : <any>null;
            this.isRecruiter = _data["isRecruiter"] !== undefined ? _data["isRecruiter"] : <any>null;
            this.site = _data["site"] ? Site.fromJS(_data["site"]) : <any>null;
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["surnamme"] = this.surnamme !== undefined ? this.surnamme : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["yearsOfExperience"] = this.yearsOfExperience !== undefined ? this.yearsOfExperience : <any>null;
        data["position"] = this.position !== undefined ? this.position : <any>null;
        data["remote"] = this.remote !== undefined ? this.remote : <any>null;
        data["isRecruiter"] = this.isRecruiter !== undefined ? this.isRecruiter : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        return data;
    }
}

export class Research {
    researchId?: string;
    code?: number;
    description?: string | null;
    remote?: boolean;
    siteId?: string;
    personId?: string;
    languageId?: string;
    person?: Person;
    language?: Language;
    site?: Site;

    init(_data?: any) {
        if (_data) {
            this.researchId = _data["researchId"] !== undefined ? _data["researchId"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.remote = _data["remote"] !== undefined ? _data["remote"] : <any>null;
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.languageId = _data["languageId"] !== undefined ? _data["languageId"] : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>null;
            this.site = _data["site"] ? Site.fromJS(_data["site"]) : <any>null;
        }
    }

    static fromJS(data: any): Research {
        data = typeof data === 'object' ? data : {};
        let result = new Research();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["researchId"] = this.researchId !== undefined ? this.researchId : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["remote"] = this.remote !== undefined ? this.remote : <any>null;
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["languageId"] = this.languageId !== undefined ? this.languageId : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        data["language"] = this.language ? this.language.toJSON() : <any>null;
        data["site"] = this.site ? this.site.toJSON() : <any>null;
        return data;
    }
}

export class Site {
    siteId?: string;
    code?: number;
    description?: string | null;

    init(_data?: any) {
        if (_data) {
            this.siteId = _data["siteId"] !== undefined ? _data["siteId"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): Site {
        data = typeof data === 'object' ? data : {};
        let result = new Site();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteId"] = this.siteId !== undefined ? this.siteId : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export class Skill {
    skillId?: string;
    code?: number;
    febeDevops?: string | null;
    webMobile?: string | null;
    technology?: string | null;
    projectRef?: string | null;
    description?: string | null;

    init(_data?: any) {
        if (_data) {
            this.skillId = _data["skillId"] !== undefined ? _data["skillId"] : <any>null;
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.febeDevops = _data["febeDevops"] !== undefined ? _data["febeDevops"] : <any>null;
            this.webMobile = _data["webMobile"] !== undefined ? _data["webMobile"] : <any>null;
            this.technology = _data["technology"] !== undefined ? _data["technology"] : <any>null;
            this.projectRef = _data["projectRef"] !== undefined ? _data["projectRef"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skillId"] = this.skillId !== undefined ? this.skillId : <any>null;
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["febeDevops"] = this.febeDevops !== undefined ? this.febeDevops : <any>null;
        data["webMobile"] = this.webMobile !== undefined ? this.webMobile : <any>null;
        data["technology"] = this.technology !== undefined ? this.technology : <any>null;
        data["projectRef"] = this.projectRef !== undefined ? this.projectRef : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        return data;
    }
}

export class SkillLink {
    skillLinkId?: string;
    skillId?: string;
    personId?: string;
    level?: number;
    skill?: Skill;
    person?: Person;

    init(_data?: any) {
        if (_data) {
            this.skillLinkId = _data["skillLinkId"] !== undefined ? _data["skillLinkId"] : <any>null;
            this.skillId = _data["skillId"] !== undefined ? _data["skillId"] : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.level = _data["level"] !== undefined ? _data["level"] : <any>null;
            this.skill = _data["skill"] ? Skill.fromJS(_data["skill"]) : <any>null;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>null;
        }
    }

    static fromJS(data: any): SkillLink {
        data = typeof data === 'object' ? data : {};
        let result = new SkillLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skillLinkId"] = this.skillLinkId !== undefined ? this.skillLinkId : <any>null;
        data["skillId"] = this.skillId !== undefined ? this.skillId : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["level"] = this.level !== undefined ? this.level : <any>null;
        data["skill"] = this.skill ? this.skill.toJSON() : <any>null;
        data["person"] = this.person ? this.person.toJSON() : <any>null;
        return data;
    }
}

export class StringStringIEnumerableKeyValuePair {
    key?: string | null;
    value?: string[] | null;

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"] !== undefined ? _data["key"] : <any>null;
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
            else {
                this.value = <any>null;
            }
        }
    }

    static fromJS(data: any): StringStringIEnumerableKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringIEnumerableKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export class Version {
    readonly major?: number;
    readonly minor?: number;
    readonly build?: number;
    readonly revision?: number;
    readonly majorRevision?: number;
    readonly minorRevision?: number;

    init(_data?: any) {
        if (_data) {
            (<any>this).major = _data["major"] !== undefined ? _data["major"] : <any>null;
            (<any>this).minor = _data["minor"] !== undefined ? _data["minor"] : <any>null;
            (<any>this).build = _data["build"] !== undefined ? _data["build"] : <any>null;
            (<any>this).revision = _data["revision"] !== undefined ? _data["revision"] : <any>null;
            (<any>this).majorRevision = _data["majorRevision"] !== undefined ? _data["majorRevision"] : <any>null;
            (<any>this).minorRevision = _data["minorRevision"] !== undefined ? _data["minorRevision"] : <any>null;
        }
    }

    static fromJS(data: any): Version {
        data = typeof data === 'object' ? data : {};
        let result = new Version();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["major"] = this.major !== undefined ? this.major : <any>null;
        data["minor"] = this.minor !== undefined ? this.minor : <any>null;
        data["build"] = this.build !== undefined ? this.build : <any>null;
        data["revision"] = this.revision !== undefined ? this.revision : <any>null;
        data["majorRevision"] = this.majorRevision !== undefined ? this.majorRevision : <any>null;
        data["minorRevision"] = this.minorRevision !== undefined ? this.minorRevision : <any>null;
        return data;
    }
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}