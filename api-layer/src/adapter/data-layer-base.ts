//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class DataLayerClientBase {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    languageAll(  cancelToken?: CancelToken | undefined): Promise<Language[]> {
        let url_ = this.baseUrl + "/api/Language";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageAll(_response);
        });
    }

    protected processLanguageAll(response: AxiosResponse): Promise<Language[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Language.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Language[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Language[]>(null as any);
    }

    /**
     * @return Success
     */
    language(id: string , cancelToken?: CancelToken | undefined): Promise<Language> {
        let url_ = this.baseUrl + "/api/Language/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguage(_response);
        });
    }

    protected processLanguage(response: AxiosResponse): Promise<Language> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Language.fromJS(resultData200);
            return Promise.resolve<Language>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Language>(null as any);
    }

    /**
     * @return Success
     */
    languageLevelAll(  cancelToken?: CancelToken | undefined): Promise<LanguageLevel[]> {
        let url_ = this.baseUrl + "/api/LanguageLevel";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLevelAll(_response);
        });
    }

    protected processLanguageLevelAll(response: AxiosResponse): Promise<LanguageLevel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageLevel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LanguageLevel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageLevel[]>(null as any);
    }

    /**
     * @return Success
     */
    languageLevel(id: string , cancelToken?: CancelToken | undefined): Promise<LanguageLevel> {
        let url_ = this.baseUrl + "/api/LanguageLevel/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLevel(_response);
        });
    }

    protected processLanguageLevel(response: AxiosResponse): Promise<LanguageLevel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageLevel.fromJS(resultData200);
            return Promise.resolve<LanguageLevel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageLevel>(null as any);
    }

    /**
     * @return Success
     */
    languageLinkAll(  cancelToken?: CancelToken | undefined): Promise<LanguageLink[]> {
        let url_ = this.baseUrl + "/api/LanguageLink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLinkAll(_response);
        });
    }

    protected processLanguageLinkAll(response: AxiosResponse): Promise<LanguageLink[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageLink.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LanguageLink[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageLink[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    languageLinkPOST(body: LanguageLink | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/LanguageLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLinkPOST(_response);
        });
    }

    protected processLanguageLinkPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    languageLinkGET(id: string , cancelToken?: CancelToken | undefined): Promise<LanguageLink> {
        let url_ = this.baseUrl + "/api/LanguageLink/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLanguageLinkGET(_response);
        });
    }

    protected processLanguageLinkGET(response: AxiosResponse): Promise<LanguageLink> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguageLink.fromJS(resultData200);
            return Promise.resolve<LanguageLink>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguageLink>(null as any);
    }

    /**
     * @return Success
     */
    personAll(  cancelToken?: CancelToken | undefined): Promise<Person[]> {
        let url_ = this.baseUrl + "/api/Person";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonAll(_response);
        });
    }

    protected processPersonAll(response: AxiosResponse): Promise<Person[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Person.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Person[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Person[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    personPOST(body: Person | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Person";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonPOST(_response);
        });
    }

    protected processPersonPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    personGET(id: string , cancelToken?: CancelToken | undefined): Promise<Person> {
        let url_ = this.baseUrl + "/api/Person/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPersonGET(_response);
        });
    }

    protected processPersonGET(response: AxiosResponse): Promise<Person> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Person.fromJS(resultData200);
            return Promise.resolve<Person>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Person>(null as any);
    }

    /**
     * @return Success
     */
    researchAll(  cancelToken?: CancelToken | undefined): Promise<Research[]> {
        let url_ = this.baseUrl + "/api/Research";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResearchAll(_response);
        });
    }

    protected processResearchAll(response: AxiosResponse): Promise<Research[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Research.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Research[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Research[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    researchPOST(body: Research | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Research";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResearchPOST(_response);
        });
    }

    protected processResearchPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    researchGET(id: string , cancelToken?: CancelToken | undefined): Promise<Research> {
        let url_ = this.baseUrl + "/api/Research/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResearchGET(_response);
        });
    }

    protected processResearchGET(response: AxiosResponse): Promise<Research> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Research.fromJS(resultData200);
            return Promise.resolve<Research>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Research>(null as any);
    }

    /**
     * @return Success
     */
    siteAll(  cancelToken?: CancelToken | undefined): Promise<Site[]> {
        let url_ = this.baseUrl + "/api/Site";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSiteAll(_response);
        });
    }

    protected processSiteAll(response: AxiosResponse): Promise<Site[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Site.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Site[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Site[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sitePOST(body: Site | undefined , cancelToken?: CancelToken | undefined): Promise<HttpResponseMessage> {
        let url_ = this.baseUrl + "/api/Site";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSitePOST(_response);
        });
    }

    protected processSitePOST(response: AxiosResponse): Promise<HttpResponseMessage> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HttpResponseMessage.fromJS(resultData200);
            return Promise.resolve<HttpResponseMessage>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HttpResponseMessage>(null as any);
    }

    /**
     * @return Success
     */
    siteGET(id: string , cancelToken?: CancelToken | undefined): Promise<Site> {
        let url_ = this.baseUrl + "/api/Site/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSiteGET(_response);
        });
    }

    protected processSiteGET(response: AxiosResponse): Promise<Site> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Site.fromJS(resultData200);
            return Promise.resolve<Site>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Site>(null as any);
    }

    /**
     * @return Success
     */
    skillAll(  cancelToken?: CancelToken | undefined): Promise<Skill[]> {
        let url_ = this.baseUrl + "/api/Skill";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillAll(_response);
        });
    }

    protected processSkillAll(response: AxiosResponse): Promise<Skill[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Skill.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Skill[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Skill[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    skillPOST(body: Skill | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Skill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillPOST(_response);
        });
    }

    protected processSkillPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    skillGET(id: string , cancelToken?: CancelToken | undefined): Promise<Skill> {
        let url_ = this.baseUrl + "/api/Skill/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillGET(_response);
        });
    }

    protected processSkillGET(response: AxiosResponse): Promise<Skill> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Skill.fromJS(resultData200);
            return Promise.resolve<Skill>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Skill>(null as any);
    }

    /**
     * @return Success
     */
    skillLinkAll(  cancelToken?: CancelToken | undefined): Promise<SkillLink[]> {
        let url_ = this.baseUrl + "/api/SkillLink";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillLinkAll(_response);
        });
    }

    protected processSkillLinkAll(response: AxiosResponse): Promise<SkillLink[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SkillLink.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SkillLink[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SkillLink[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    skillLinkPOST(body: SkillLink | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/SkillLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillLinkPOST(_response);
        });
    }

    protected processSkillLinkPOST(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    skillLinkGET(id: string , cancelToken?: CancelToken | undefined): Promise<SkillLink> {
        let url_ = this.baseUrl + "/api/SkillLink/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSkillLinkGET(_response);
        });
    }

    protected processSkillLinkGET(response: AxiosResponse): Promise<SkillLink> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SkillLink.fromJS(resultData200);
            return Promise.resolve<SkillLink>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SkillLink>(null as any);
    }
}

export class HttpContent {
    readonly headers!: StringStringIEnumerableKeyValuePair[] | undefined;

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["headers"])) {
                (<any>this).headers = [] as any;
                for (let item of _data["headers"])
                    (<any>this).headers!.push(StringStringIEnumerableKeyValuePair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HttpContent {
        data = typeof data === 'object' ? data : {};
        let result = new HttpContent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.headers)) {
            data["headers"] = [];
            for (let item of this.headers)
                data["headers"].push(item.toJSON());
        }
        return data;
    }
}

export class HttpMethod {
    method!: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.method = _data["method"];
        }
    }

    static fromJS(data: any): HttpMethod {
        data = typeof data === 'object' ? data : {};
        let result = new HttpMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["method"] = this.method;
        return data;
    }
}

export class HttpRequestMessage {
    version!: Version;
    versionPolicy!: HttpVersionPolicy;
    content!: HttpContent;
    method!: HttpMethod;
    requestUri!: string | undefined;
    readonly headers!: StringStringIEnumerableKeyValuePair[] | undefined;
    readonly properties!: { [key: string]: any; } | undefined;
    readonly options!: { [key: string]: any; } | undefined;

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] ? Version.fromJS(_data["version"]) : <any>undefined;
            this.versionPolicy = _data["versionPolicy"];
            this.content = _data["content"] ? HttpContent.fromJS(_data["content"]) : <any>undefined;
            this.method = _data["method"] ? HttpMethod.fromJS(_data["method"]) : <any>undefined;
            this.requestUri = _data["requestUri"];
            if (Array.isArray(_data["headers"])) {
                (<any>this).headers = [] as any;
                for (let item of _data["headers"])
                    (<any>this).headers!.push(StringStringIEnumerableKeyValuePair.fromJS(item));
            }
            if (_data["properties"]) {
                (<any>this).properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>(<any>this).properties)![key] = _data["properties"][key];
                }
            }
            if (_data["options"]) {
                (<any>this).options = {} as any;
                for (let key in _data["options"]) {
                    if (_data["options"].hasOwnProperty(key))
                        (<any>(<any>this).options)![key] = _data["options"][key];
                }
            }
        }
    }

    static fromJS(data: any): HttpRequestMessage {
        data = typeof data === 'object' ? data : {};
        let result = new HttpRequestMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        data["versionPolicy"] = this.versionPolicy;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["method"] = this.method ? this.method.toJSON() : <any>undefined;
        data["requestUri"] = this.requestUri;
        if (Array.isArray(this.headers)) {
            data["headers"] = [];
            for (let item of this.headers)
                data["headers"].push(item.toJSON());
        }
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        if (this.options) {
            data["options"] = {};
            for (let key in this.options) {
                if (this.options.hasOwnProperty(key))
                    (<any>data["options"])[key] = (<any>this.options)[key];
            }
        }
        return data;
    }
}

export class HttpResponseMessage {
    version!: Version;
    content!: HttpContent;
    statusCode!: HttpStatusCode;
    reasonPhrase!: string | undefined;
    readonly headers!: StringStringIEnumerableKeyValuePair[] | undefined;
    readonly trailingHeaders!: StringStringIEnumerableKeyValuePair[] | undefined;
    requestMessage!: HttpRequestMessage;
    readonly isSuccessStatusCode!: boolean;

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"] ? Version.fromJS(_data["version"]) : <any>undefined;
            this.content = _data["content"] ? HttpContent.fromJS(_data["content"]) : <any>undefined;
            this.statusCode = _data["statusCode"];
            this.reasonPhrase = _data["reasonPhrase"];
            if (Array.isArray(_data["headers"])) {
                (<any>this).headers = [] as any;
                for (let item of _data["headers"])
                    (<any>this).headers!.push(StringStringIEnumerableKeyValuePair.fromJS(item));
            }
            if (Array.isArray(_data["trailingHeaders"])) {
                (<any>this).trailingHeaders = [] as any;
                for (let item of _data["trailingHeaders"])
                    (<any>this).trailingHeaders!.push(StringStringIEnumerableKeyValuePair.fromJS(item));
            }
            this.requestMessage = _data["requestMessage"] ? HttpRequestMessage.fromJS(_data["requestMessage"]) : <any>undefined;
            (<any>this).isSuccessStatusCode = _data["isSuccessStatusCode"];
        }
    }

    static fromJS(data: any): HttpResponseMessage {
        data = typeof data === 'object' ? data : {};
        let result = new HttpResponseMessage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version ? this.version.toJSON() : <any>undefined;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["statusCode"] = this.statusCode;
        data["reasonPhrase"] = this.reasonPhrase;
        if (Array.isArray(this.headers)) {
            data["headers"] = [];
            for (let item of this.headers)
                data["headers"].push(item.toJSON());
        }
        if (Array.isArray(this.trailingHeaders)) {
            data["trailingHeaders"] = [];
            for (let item of this.trailingHeaders)
                data["trailingHeaders"].push(item.toJSON());
        }
        data["requestMessage"] = this.requestMessage ? this.requestMessage.toJSON() : <any>undefined;
        data["isSuccessStatusCode"] = this.isSuccessStatusCode;
        return data;
    }
}

export enum HttpStatusCode {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export enum HttpVersionPolicy {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class Language {
    languageId!: string;
    code!: number;
    description!: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.languageId = _data["languageId"];
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Language {
        data = typeof data === 'object' ? data : {};
        let result = new Language();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageId"] = this.languageId;
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export class LanguageLevel {
    languageLevelId!: string;
    code!: number;
    description!: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.languageLevelId = _data["languageLevelId"];
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): LanguageLevel {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageLevel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageLevelId"] = this.languageLevelId;
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export class LanguageLink {
    languageLinkId!: string;
    languageId!: string;
    personId!: string;
    languageLevelId!: string | undefined;
    preferred!: boolean | undefined;
    language!: Language;
    person!: Person;
    languageLevel!: LanguageLevel;

    init(_data?: any) {
        if (_data) {
            this.languageLinkId = _data["languageLinkId"];
            this.languageId = _data["languageId"];
            this.personId = _data["personId"];
            this.languageLevelId = _data["languageLevelId"];
            this.preferred = _data["preferred"];
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>undefined;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>undefined;
            this.languageLevel = _data["languageLevel"] ? LanguageLevel.fromJS(_data["languageLevel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LanguageLink {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageLinkId"] = this.languageLinkId;
        data["languageId"] = this.languageId;
        data["personId"] = this.personId;
        data["languageLevelId"] = this.languageLevelId;
        data["preferred"] = this.preferred;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["languageLevel"] = this.languageLevel ? this.languageLevel.toJSON() : <any>undefined;
        return data;
    }
}

export class Person {
    personId!: string;
    code!: number;
    name!: string | undefined;
    surnamme!: string | undefined;
    siteId!: string | undefined;
    yearsOfExperience!: number | undefined;
    position!: string | undefined;
    remote!: boolean;
    isRecruiter!: boolean;
    site!: Site;

    init(_data?: any) {
        if (_data) {
            this.personId = _data["personId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.surnamme = _data["surnamme"];
            this.siteId = _data["siteId"];
            this.yearsOfExperience = _data["yearsOfExperience"];
            this.position = _data["position"];
            this.remote = _data["remote"];
            this.isRecruiter = _data["isRecruiter"];
            this.site = _data["site"] ? Site.fromJS(_data["site"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["personId"] = this.personId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["surnamme"] = this.surnamme;
        data["siteId"] = this.siteId;
        data["yearsOfExperience"] = this.yearsOfExperience;
        data["position"] = this.position;
        data["remote"] = this.remote;
        data["isRecruiter"] = this.isRecruiter;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        return data;
    }
}

export class Research {
    researchId!: string;
    code!: number;
    description!: string | undefined;
    remote!: boolean;
    siteId!: string;
    personId!: string;
    languageId!: string;
    person!: Person;
    language!: Language;
    site!: Site;

    init(_data?: any) {
        if (_data) {
            this.researchId = _data["researchId"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.remote = _data["remote"];
            this.siteId = _data["siteId"];
            this.personId = _data["personId"];
            this.languageId = _data["languageId"];
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>undefined;
            this.language = _data["language"] ? Language.fromJS(_data["language"]) : <any>undefined;
            this.site = _data["site"] ? Site.fromJS(_data["site"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Research {
        data = typeof data === 'object' ? data : {};
        let result = new Research();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["researchId"] = this.researchId;
        data["code"] = this.code;
        data["description"] = this.description;
        data["remote"] = this.remote;
        data["siteId"] = this.siteId;
        data["personId"] = this.personId;
        data["languageId"] = this.languageId;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["site"] = this.site ? this.site.toJSON() : <any>undefined;
        return data;
    }
}

export class Site {
    siteId!: string;
    code!: number;
    description!: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.siteId = _data["siteId"];
            this.code = _data["code"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Site {
        data = typeof data === 'object' ? data : {};
        let result = new Site();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["siteId"] = this.siteId;
        data["code"] = this.code;
        data["description"] = this.description;
        return data;
    }
}

export class Skill {
    skillId!: string;
    code!: number;
    febeDevops!: string | undefined;
    webMobile!: string | undefined;
    technology!: string | undefined;
    projectRef!: string | undefined;
    description!: string | undefined;

    init(_data?: any) {
        if (_data) {
            this.skillId = _data["skillId"];
            this.code = _data["code"];
            this.febeDevops = _data["febeDevops"];
            this.webMobile = _data["webMobile"];
            this.technology = _data["technology"];
            this.projectRef = _data["projectRef"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Skill {
        data = typeof data === 'object' ? data : {};
        let result = new Skill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skillId"] = this.skillId;
        data["code"] = this.code;
        data["febeDevops"] = this.febeDevops;
        data["webMobile"] = this.webMobile;
        data["technology"] = this.technology;
        data["projectRef"] = this.projectRef;
        data["description"] = this.description;
        return data;
    }
}

export class SkillLink {
    skillLinkId!: string;
    skillId!: string;
    personId!: string;
    level!: number;
    skill!: Skill;
    person!: Person;

    init(_data?: any) {
        if (_data) {
            this.skillLinkId = _data["skillLinkId"];
            this.skillId = _data["skillId"];
            this.personId = _data["personId"];
            this.level = _data["level"];
            this.skill = _data["skill"] ? Skill.fromJS(_data["skill"]) : <any>undefined;
            this.person = _data["person"] ? Person.fromJS(_data["person"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SkillLink {
        data = typeof data === 'object' ? data : {};
        let result = new SkillLink();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skillLinkId"] = this.skillLinkId;
        data["skillId"] = this.skillId;
        data["personId"] = this.personId;
        data["level"] = this.level;
        data["skill"] = this.skill ? this.skill.toJSON() : <any>undefined;
        data["person"] = this.person ? this.person.toJSON() : <any>undefined;
        return data;
    }
}

export class StringStringIEnumerableKeyValuePair {
    key!: string | undefined;
    value!: string[] | undefined;

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(item);
            }
        }
    }

    static fromJS(data: any): StringStringIEnumerableKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringIEnumerableKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item);
        }
        return data;
    }
}

export class Version {
    readonly major!: number;
    readonly minor!: number;
    readonly build!: number;
    readonly revision!: number;
    readonly majorRevision!: number;
    readonly minorRevision!: number;

    init(_data?: any) {
        if (_data) {
            (<any>this).major = _data["major"];
            (<any>this).minor = _data["minor"];
            (<any>this).build = _data["build"];
            (<any>this).revision = _data["revision"];
            (<any>this).majorRevision = _data["majorRevision"];
            (<any>this).minorRevision = _data["minorRevision"];
        }
    }

    static fromJS(data: any): Version {
        data = typeof data === 'object' ? data : {};
        let result = new Version();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["major"] = this.major;
        data["minor"] = this.minor;
        data["build"] = this.build;
        data["revision"] = this.revision;
        data["majorRevision"] = this.majorRevision;
        data["minorRevision"] = this.minorRevision;
        return data;
    }
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}